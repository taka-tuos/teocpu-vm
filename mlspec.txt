teocpu-vm 仕様書(仮)

§特徴
32bit-RISC
レジスタ66本(r0-r63,pc,sp)
固定小数演算機能
リトルエンディアン
スタックの有効活用による高速化可能なアーキテクチャ
SIMD命令搭載

§各レジスタの役割
r0-r15  : 汎用レジスタ(固定小数レジスタとして扱う場合 整数部28bit 小数部4bit)
r16-r31 : 汎用レジスタ(固定小数レジスタとして扱う場合 整数部24bit 小数部8bit)
r32-r47 : 汎用レジスタ(固定小数レジスタとして扱う場合 整数部22bit 小数部10bit)
r48-r63 : 汎用レジスタ(固定小数レジスタとして扱う場合 整数部16bit 小数部16bit)
r64     : プログラムカウンタ
r65     : スタックポインタ

§命令リスト表記凡例
[命令名] [引数(ない場合もあり)]
 [opコード/16進2ケタ] [引数データ/16進2ケタ区切り]
  [処理内容/下の注釈の構文を除き基本的にC99準拠]
[説明]

引数 :
	r   : レジスタ
	imm : 即値(imm16,imm8など特記なき場合32bit)

引数データ :
	rr : レジスタ番号(0-65)
	xx : 即値のうち8bit(並びはリトルエンディアン)

処理内容 :
	D[xx]      : メモリのxx番地(32bitアクセス)
	W[xx]      : メモリのxx番地(16bitアクセス)
	B[xx]      : メモリのxx番地(8bitアクセス)
	r          : 引数(レジスタ)
	imm        : 引数(即値)
	push(xx)   : D[sp] = xx; sp += 4
	pop(xx)    : sp -= 4; xx = D[sp]
	#name      : 一時的に数値を保存する内部変数
	[operator] : 符号なし演算(乗算・除算・大小比較時のみ関係アリ)

§命令リスト(多分そのうち増えます)

NOP
 00
  (no operation)
何もせず素通りする

LR r
 01 rr
  push(r)
スタックにレジスタの値を積む

LI imm
 02 xx xx xx xx
  push(imm)
スタックに即値を積む

SR r
 03 rr
  pop(r)
スタックからとった値をレジスタに入れる

STB
 04
  pop(#offset_addr)
  pop(#base_addr)
  pop(#data)
  B[#base_addr + #offset_addr] = #data & 0xff
スタックに積んである値を上からオフセット・ベースアドレス・データと解釈し
ベースアドレス+オフセット番地にデータを書き込む(8bitアクセス)

STW
 05
  pop(#offset_addr)
  pop(#base_addr)
  pop(#data)
  W[#base_addr + #offset_addr] = #data & 0xffff
スタックに積んである値を上からオフセット・ベースアドレス・データと解釈し
ベースアドレス+オフセット番地にデータを書き込む(16bitアクセス)

STD
 06
  pop(#offset_addr)
  pop(#base_addr)
  pop(#data)
  D[#base_addr + #offset_addr] = #data
スタックに積んである値を上からオフセット・ベースアドレス・データと解釈し
ベースアドレス+オフセット番地にデータを書き込む(32bitアクセス)

LDB
 07
  pop(#offset_addr)
  pop(#base_addr)
  push(B[#base_addr + #offset_addr])
スタックに積んである値を上からオフセット・ベースアドレスと解釈し
ベースアドレス+オフセット番地のデータをスタックに積む(8bitアクセス)

LDW
 08
  pop(#offset_addr)
  pop(#base_addr)
  push(W[#base_addr + #offset_addr])
スタックに積んである値を上からオフセット・ベースアドレスと解釈し
ベースアドレス+オフセット番地のデータをスタックに積む(16bitアクセス)

LDD
 09
  pop(#offset_addr)
  pop(#base_addr)
  push(D[#base_addr + #offset_addr])
スタックに積んである値を上からオフセット・ベースアドレスと解釈し
ベースアドレス+オフセット番地のデータをスタックに積む(32bitアクセス)

ADD
 0A
  pop(#a)
  pop(#b)
  push(#a + #b)
スタックの上から2つ分の値を足してスタックに積む

SUB
 0B
  pop(#a)
  pop(#b)
  push(#a - #b)
スタックの1番上の値から2番目の値を引いてスタックに積む

MUL
 0C
  pop(#a)
  pop(#b)
  push(#a [*] #b)
スタックの上から2つ分の値をかけてスタックに積む(符号なし)

DIV
 0D
  pop(#a)
  pop(#b)
  push(#a [/] #b)
  push(#a [%] #b)
スタックの1番上の値を2番目の値で割ってスタックに積み、さらに余りを積む(符号なし)

MULI
 0E
  pop(#a)
  pop(#b)
  push(#a * #b)
スタックの上から2つ分の値をかけてスタックに積む(符号あり)

DIVI
 0F
  pop(#a)
  pop(#b)
  push(#a / #b)
  push(#a % #b)
スタックの1番上の値を2番目の値で割ってスタックに積み、さらに余りを積む(符号あり)

NEG
 10
  pop(#n)
  push((#n ^ 0xffffffff) + 1)
スタックの1番上の値を符号付き32bit整数と解釈し符号を反転し、それをスタックに積む

ABS
 11
  pop(#n)
  push((#n - (#n >> 31)) ^ (0xffffffff [*] (#n >> 31)))
スタックの1番上の値を符号付き32bit整数と解釈し、その絶対値をスタックに積む

SXB
 12
  pop(#b)
  push((0xffffff [*] (#b & 0x80)) | (#b & 0x7f))
スタックの1番上の値を8bitから32bitに符号拡張してスタックに積む

SXW
 13
  pop(#w)
  push(0xFFFF * (#w & 0x8000) | (#w & 0x7fff))
スタックの1番上の値を16bitから32bitに符号拡張してスタックに積む

AND
 14
  pop(#a)
  pop(#b)
  push(#a & #b)
スタックの上から2つ分の値のANDをとり、それをスタックに積む

OR
 15
  pop(#a)
  pop(#b)
  push(#a | #b)
スタックの上から2つ分の値のORをとり、それをスタックに積む

XOR
 16
  pop(#a)
  pop(#b)
  push(#a ^ #b)
スタックの上から2つ分の値のXORをとり、それをスタックに積む

NOT
 17
  pop(#n)
  push(#n ^ 0xffffffff)
スタックの1番上の値の全ビットを反転させ、それをスタックに積む

CMP
 18
  pop(#a)
  pop(#b)
  push((#a > #b ? 0b001 : 0) | (#a < #b ? 0b010 : 0) | (#a == #b ? 0b100 : 0))
スタックの上から2つ分の値を比較し、その結果をスタックに積む(符号なし)

CMPI
 19
  pop(#a)
  pop(#b)
  push((#a [>] #b ? 0b001 : 0) | (#a [<] #b ? 0b010 : 0) | (#a == #b ? 0b100 : 0))
スタックの上から2つ分の値を比較し、その結果をスタックに積む(符号あり)
  